// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`miscMds inline code works 1`] = `
<article>
  <p>
    A modern, database-agnostic, composable SELECT query builder with great
    typescript support.
  </p>
  <HeadingGrommet id="install" originalNodeName="h1">Install</HeadingGrommet>
  <p>Install from npm</p>
  <Fence
    content="npm i sql-select-ts
"
    >npm i sql-select-ts </Fence
  ><HeadingGrommet id="features" originalNodeName="h1">Features</HeadingGrommet
  ><HeadingGrommet id="modern" originalNodeName="h2">Modern</HeadingGrommet>
  <p>
    Built with modern typescript and javascript features, it delivers a clean,
    easy-to-use and powerful API that couldn't exist before.
  </p>
  <p>Such features include:</p>
  <HeadingGrommet
    id="safe-string-interpolation-with-template-literals"
    originalNodeName="h4"
    >Safe string interpolation with template literals</HeadingGrommet
  ><Fence
    content="const userInput = &quot;SomeName&quot;;
const myString = sql\`column = \${userInput}\`;
// Prints:
// column = 'SomeName'

const userInput = 123;
const myString = sql\`column = \${userInput}\`;
// Prints:
// column = 123

const userInput = &quot;';&quot;;
const myString = sql\`column = \${userInput}\`;
// Prints:
// column = '\\';'
"
    language="ts"
    >const userInput = &quot;SomeName&quot;; const myString = sql\`column =
    \${userInput}\`; // Prints: // column = 'SomeName' const userInput = 123;
    const myString = sql\`column = \${userInput}\`; // Prints: // column = 123
    const userInput = &quot;';&quot;; const myString = sql\`column =
    \${userInput}\`; // Prints: // column = '\\';' </Fence
  ><HeadingGrommet id="typescript-template-literal-types" originalNodeName="h4"
    >Typescript template literal types</HeadingGrommet
  >
  <p>
    Provides type checking for identifiers names, with optional source
    qualifier, among other features.
  </p>
  <Fence
    content='const t1 = table(
  /* columns: */ ["a", "b", "c"],
  /* db-name &amp; alias: */ "t1"
);
const t2 = table(
  /* columns: */ ["b", "c", "d"],
  /* db-name &amp; alias: */ "t2"
);
t1.joinTable("NATURAL", t2)
  .using(["b"])
  .select((f) =&gt; ({
    // (parameter) f: Record&lt;
    //   "a" | "d" | "t1.a" | "t1.b" | "t1.c" | "t2.b" | "t2.c" | "t2.d",
    // SafeString&gt;
    z: f["t1.c"],
  }));
'
    language="ts"
    >const t1 = table( /* columns: */ [&quot;a&quot;, &quot;b&quot;,
    &quot;c&quot;], /* db-name &amp; alias: */ &quot;t1&quot; ); const t2 =
    table( /* columns: */ [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;], /*
    db-name &amp; alias: */ &quot;t2&quot; ); t1.joinTable(&quot;NATURAL&quot;,
    t2) .using([&quot;b&quot;]) .select((f) =&gt; ({ // (parameter) f:
    Record&lt; // &quot;a&quot; | &quot;d&quot; | &quot;t1.a&quot; |
    &quot;t1.b&quot; | &quot;t1.c&quot; | &quot;t2.b&quot; | &quot;t2.c&quot; |
    &quot;t2.d&quot;, // SafeString&gt; z: f[&quot;t1.c&quot;], })); </Fence
  ><HeadingGrommet id="database-agnostic" originalNodeName="h2"
    >Database agnostic</HeadingGrommet
  >
  <p>
    We focus on generating correct SQL syntax-wise, and let you take care of
    semantics.
  </p>
  <p>This allows usage in any SQL database.</p>
  <HeadingGrommet id="usage-with-sqlite" originalNodeName="h4"
    >Usage with sqlite</HeadingGrommet
  >
  <p>TODO</p>
  <HeadingGrommet id="usage-with-clickhouse" originalNodeName="h4"
    >Usage with Clickhouse</HeadingGrommet
  >
  <p>TODO</p>
  <HeadingGrommet id="composable" originalNodeName="h2"
    >Composable</HeadingGrommet
  >
  <p>TODO</p>
  <HeadingGrommet id="typescript-support" originalNodeName="h2"
    >Typescript support</HeadingGrommet
  >
  <p>TODO</p>
  <HeadingGrommet id="well-tested" originalNodeName="h2"
    >Well tested</HeadingGrommet
  >
  <p>TODO</p>
  <HeadingGrommet id="getting-started" originalNodeName="h1"
    >Getting started</HeadingGrommet
  >
  <p>TODO</p>
</article>

`;
